import { Container, Item } from "./components.javascript"

export const meta = {
  title: "Introduction Ã  Parcel, leÂ WebÂ ApplicationÂ Bundler zero config",
  description: "Mais vraiment.",
  cover: require("./cover.jpg"),
  coverPosition: 40,
}

Bonjour et bienvenuÂ·e aujourd'hui pour une petite introduction Ã  [Parcel](https://parceljs.org/), ce bundler (pensez [Gulp.js](https://gulpjs.com/), [webpack](https://webpack.js.org/!)) qui arrive avec une promesse - pas des moindres - d'Ãªtre super rapide âš¡, et ce sans aucune configuration Ã  dÃ©finir ğŸ™ŒğŸ». PlutÃ´t sÃ©duisant dit comme Ã§a. C'est ce que nous allons voir.

## Pourquoi avez-nous besoin d'un bundler ?

C'est la premiÃ¨re question qu'on doit se poser, pourquoi avons-nous besoin de celaÂ ?

Il y a plusieurs raisons Ã  avoir envie d'un bundler, et les voiciÂ :

- vous voulez optimiser vos images,
- vous voulez minifier vos fichiers CSS, HTML, JS ;
- vous voulez rÃ©duire le nombre de requÃªtes HTTP en fusionnant plusieurs fichiers de mÃªme type ensemble,
- vous voulez sÃ©parer votre code afin d'en faire des modules mais joindre tout Ã§a Ã  la fin,
- vous voulez enfin Ã©crire dans une version avancÃ©e de ECMAScript (comme ES6 ou ES7) mais que cela soit compris par tous les navigateurs Ã  la fin.

VoilÃ  les principales diffÃ©rentes raisons de pourquoi on aimerait un bundler. On souhaite aussi que celui-ci _watch_ vos fichiers afin de recompiler Ã  chaque changement de ceux-ci.

## Parlons maintenant des bundlers du marchÃ©

Je ne connais pas votre parcours, mais dans mon cas, je suis passÃ© par pas mal d'Ã©tapes. Ã‡a a Ã©tÃ© de gÃ©rer les _assets_ Ã  travers [Django](https://www.djangoproject.com/), [Ruby on Rails](https://rubyonrails.org/), [Symfony](https://symfony.com/) cÃ´tÃ© back. CÃ´tÃ© front, Ã  utiliser d'abord [Grunt](https://gruntjs.com/) puis Gulp puis webpack, en passant par quelques scripts shell. Et mÃªme si Ã§a Ã©tÃ© efficace et Ã§a l'est toujours, je crois que le plus traumatisant pour moi a Ã©tÃ© de maintenir mon bundler sur Gulp avec [browserify](http://browserify.org/). Chacun avait son propre systÃ¨me de stream et pour mÃ©langer tout Ã§a, _poh poh poh_, c'Ã©tait coton.

Heureusement est arrivÃ© par la suite [Babel](https://babeljs.io/), mais j'avais rapidement birfuquÃ© Ã  ce moment lÃ  sur webpack, donc l'expÃ©rience Gulp + Babel n'a jamais Ã©tÃ© vraiment un sujet pour le moment chez moi.

CÃ´tÃ© webpack, rien Ã  dire, c'est assez dÃ©claratif certes, faut connaÃ®tre un peu les regex, j'ai eu aussi une certaine douleur lorsqu'il y avait des changements d'API majeurs mais dans l'ensemble j'en suis plutÃ´t content, et je n'arrive pas Ã  vouloir utiliser [create-react-app](https://reactjs.org/docs/create-a-new-react-app.html) (appelÃ© CRA dans la suite du texte) tellement je suis bien Ã  configurer webpack aux petits oignons ğŸ§…. Alors, certes quand je dois _shipper_ un produit assez rapidement ou faire un _PoC_ (proof-of-concept), je vous avoue que je pourrais utiliser CRA. Mais c'est justement ce qui me fait venir Ã  parler de Parcel justement !

L'idÃ©e de Parcel est de ne pas vous prÃ©occuper de votre bundler, et de simplement coder directement votre application sans avoir Ã  dÃ©finir chaque tÃ¢che pour chaque type de fichiers. PlutÃ´t pratique. Alors oui, webpack a fait d'Ã©norme effort (surtout depuis la version 4) pour Ãªtre _zero config_ Ã  travers ces modes `development` et `production` mais je n'ai pas testÃ© ce cas.

## Introduction Ã  Parcel

<img src={require("./parcel-site.png")} />

PremiÃ¨rement le site est super propre, on comprend direct Ã  quoi on a affaire. Voici les points principaux :

<Container>
  <Item>
    <strong>ğŸš€ Des temps d'empaquetage ultra-rapide</strong>
    <p>Parcel utilise des processus de travail en parallÃ¨le pour permettre la compilation multicÅ“ur et dispose d'un cache de systÃ¨me de fichiers pour des reconstructions rapides mÃªme aprÃ¨s un redÃ©marrage.</p>
  </Item>

<Item>
  <strong>ğŸ“¦ Empaquetez toutes vos ressources</strong>
  <p>
    Parcel a un support prÃªt Ã  l'emploi pour les fichiers ressources JS, CSS,
    HTML, etc. - pas de plugins nÃ©cessaires.
  </p>
</Item>

<Item>
  <strong>ğŸ  Transformations automatiques</strong>
  <p>
    En cas de besoin, le code est automatiquement transformÃ© en utilisant Babel,
    PostCSS et PostHTML - mÃªmes les `node_modules`.
  </p>
</Item>

<Item>
  <strong>âœ‚ï¸ DÃ©coupage du code sans aucune configuration</strong>
  <p>
    En utilisant la syntaxe dynamique `import()`, Parcel dÃ©coupe la gÃ©nÃ©ration
    de vos paquets, cela permet de rÃ©cupÃ©rer seulement ce qui est nÃ©cessaire au
    chargement initial.
  </p>
</Item>

<Item>
  <strong>ğŸ”¥ Remplacement de module Ã  chaud</strong>
  <p>
    Parcel met Ã  jour automatiquement les modules dans le navigateur lorsque
    vous apportez des modifications au cours du dÃ©veloppement, aucune
    configuration n'est nÃ©cessaire.
  </p>
</Item>

<Item>
  <strong>ğŸš¨ Journalisateur* convivial</strong>
  <p>
    Parcel affiche des extraits de code avec coloration syntaxique lorsqu'il rencontre des erreurs pour vous aider Ã  identifier le problÃ¨me.
  </p>

  <p>* comprendre <em>Logger</em></p>
</Item>
</Container>

## Installons Parcel

Vous pouvez installer parcel soit globalement, soit localement, avec [yarn](https://yarnpkg.com/) ou [npm](https://www.npmjs.com/), avec comme nom de projet `parcel-bundler`. Nous l'installerons ici localement.

```shell
$ npm install parcel-bundler --save-dev
```

## CrÃ©ons notre premier projet avec Parcel

CommenÃ§ons simplement en crÃ©ant une page html basique avec un fichier JavaScript inclus.

```html
<!-- index.html -->
<!DOCTYPE html>
<html>
  <head>
    <title>Parcel Demo</title>
  </head>

  <body>
    <p>Parcel Demo</p>

    <script src="./index.js"></script>
  </body>
</html>
```

```js
// index.js
console.log("Parcel demo ğŸ™ŒğŸ»")
```

Maintenant, lanÃ§ons le mode par dÃ©faut de parcel (watch + server):

```shell
$ npx parcel index.html
```

Un serveur HTTP se lance :

<img src={require("./parcel-running.gif")} style={{ width: "50%" }} />

que nous pouvons visiter Ã  travers l'url [http://localhost:1234/](http://localhost:1234/) afin de voir notre superbe site. ğŸ™ŒğŸ»

<img src={require("./demo.png")} />

Tadaaaaaaaaa ğŸ‘¯â€â™€ï¸

Maintenant, si en revanche vous ne voulez que _watcher_ vos fichiers, Parcel vous propose une commande directe qui ne lancera pas de serveur :

```shell
$ npx parcel watch index.html
```

Enfin, afin de livrer Ã§a en production, une simple commande suffit :

```shell
$ npx parcel build index.html

âœ¨  Built in 879ms.

dist/parcel.5f6f196c.js        1.15 KB     78ms
dist/parcel.5f6f196c.js.map      200 B      2ms
dist/index.html                  144 B    750ms
```

### Arborescence

Si on regarde de plus prÃ¨s ce qui a Ã©tÃ© construit, on peut voir ceci :

```
.
â”œâ”€â”€ dist
â”‚Â Â  â”œâ”€â”€ index.html
â”‚Â Â  â”œâ”€â”€ parcel.5f6f196c.js
â”‚Â Â  â””â”€â”€ parcel.5f6f196c.js.map // sourcemaps
â”œâ”€â”€ index.html
â”œâ”€â”€ index.js
â””â”€â”€ package-lock.json
```

Nous avons bien nos fichiers sources, et dans le dossier `/dist`, les fichiers compilÃ©s sont prÃ©sents avec notre `index.html` minifiÃ©, et notre fichier JavaScript minifiÃ© ainsi que _cache bustÃ©_ (le _cache busting_ est une technique d'invalidation de caches en modifiant le nom des fichiers afin qu'ils soient reconnus comme tout autre et donc tÃ©lÃ©chargÃ©s Ã  nouveau).

---

CÃ´tÃ© CSS, vous pouvez tout aussi bien l'insÃ©rer soit en l'incluant dans le fichier HTML, soit en l'important dans votre fichier JavaScript.

```html
<!-- index.html -->
<!DOCTYPE html>
<html>
  <head>
    <title>Parcel Demo</title>
    <link rel="stylesheet" type="text/css" href="./index.css" />
  </head>

  <body>
    <p>Parcel Demo</p>

    <script src="./index.js"></script>
  </body>
</html>
```

ou

```js
// index.js

import "./index.css"

console.log("Parcel demo ğŸ™ŒğŸ»")
```

On a bien tout ce qu'il nous faut pour dÃ©buter notre projet.

## Enfin, quelques notes

Notez que Parcel supporte les [aliases](https://fr.parceljs.org/module_resolution.html), intÃ¨gre Babel dans sa compilation donc possibilitÃ© de le configurer via `.babelrc`. Et si vous avez des SVG inlines dans votre HTML et que vous avez des problÃ¨mes en sortie une fois compressÃ©s, c'est peut-Ãªtre dÃ» Ã  [htmlnano](https://github.com/posthtml/htmlnano). De ce fait, je vous recommande de dÃ©sactiver l'optimisation des SVG Ã  travers ceci :

```js
// .htmlnanorc.js
module.exports = {
  minifySvg: false,
}
```

## Conclusion ğŸ“¦

Je suis plutÃ´t impressionnÃ© par ce projet qui est vraiment clÃ© en main pour le coup. Il est devenu pour de nombreux PoC ou petits projets mon bundler par dÃ©faut. Ã€ voir si un jour je remplace webpack sur de gros projets par Parcel. En tout cas, il m'a fait oublier CRA pour le moment, et me fait gagner un temps fou quand je dÃ©bute un projet.

J'espÃ¨re que vous avez apprÃ©ciÃ© cette prÃ©sentation et que cela vous a donnÃ© envie d'essayer Parcel. Ã€Â bientÃ´tÂ !Â ğŸ‘‹ğŸ»
